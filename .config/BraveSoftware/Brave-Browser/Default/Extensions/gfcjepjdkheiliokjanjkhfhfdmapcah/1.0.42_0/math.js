const{abs:abs,cos:cos,sin:sin,acos:acos,atan2:atan2,sqrt:sqrt,pow:pow}=Math;function __crt(t){return t<0?-pow(-t,1/3):pow(t,1/3)}const __pi=Math.PI,__tau=2*__pi,__quart=__pi/2,__epsilon=1e-6,__nMax=Number.MAX_SAFE_INTEGER||9007199254740991,__nMin=Number.MIN_SAFE_INTEGER||-9007199254740991,__ZERO={x:0,y:0,z:0},__utils={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(t,i){const n=i(t);let e=n.x*n.x+n.y*n.y;return void 0!==n.z&&(e+=n.z*n.z),sqrt(e)},compute:function(t,i,n){if(0===t)return i[0].t=0,i[0];const e=i.length-1;if(1===t)return i[e].t=1,i[e];const r=1-t;let s=i;if(0===e)return i[0].t=t,i[0];if(1===e){const i={x:r*s[0].x+t*s[1].x,y:r*s[0].y+t*s[1].y,t:t};return n&&(i.z=r*s[0].z+t*s[1].z),i}if(e<4){let i,o,_,u=r*r,c=t*t,l=0;2===e?(s=[s[0],s[1],s[2],__ZERO],i=u,o=r*t*2,_=c):3===e&&(i=u*r,o=u*t*3,_=r*c*3,l=t*c);const a={x:i*s[0].x+o*s[1].x+_*s[2].x+l*s[3].x,y:i*s[0].y+o*s[1].y+_*s[2].y+l*s[3].y,t:t};return n&&(a.z=i*s[0].z+o*s[1].z+_*s[2].z+l*s[3].z),a}const o=JSON.parse(JSON.stringify(i));for(;o.length>1;){for(let i=0;i<o.length-1;i++)o[i]={x:o[i].x+(o[i+1].x-o[i].x)*t,y:o[i].y+(o[i+1].y-o[i].y)*t},void 0!==o[i].z&&(o[i]=o[i].z+(o[i+1].z-o[i].z)*t);o.splice(o.length-1,1)}return o[0].t=t,o[0]},computeWithRatios:function(t,i,n,e){const r=1-t,s=n,o=i;let _,u=s[0],c=s[1],l=s[2],a=s[3];return u*=r,c*=t,2===o.length?(_=u+c,{x:(u*o[0].x+c*o[1].x)/_,y:(u*o[0].y+c*o[1].y)/_,z:!!e&&(u*o[0].z+c*o[1].z)/_,t:t}):(u*=r,c*=2*r,l*=t*t,3===o.length?(_=u+c+l,{x:(u*o[0].x+c*o[1].x+l*o[2].x)/_,y:(u*o[0].y+c*o[1].y+l*o[2].y)/_,z:!!e&&(u*o[0].z+c*o[1].z+l*o[2].z)/_,t:t}):(u*=r,c*=1.5*r,l*=3*r,a*=t*t*t,4===o.length?(_=u+c+l+a,{x:(u*o[0].x+c*o[1].x+l*o[2].x+a*o[3].x)/_,y:(u*o[0].y+c*o[1].y+l*o[2].y+a*o[3].y)/_,z:!!e&&(u*o[0].z+c*o[1].z+l*o[2].z+a*o[3].z)/_,t:t}):void 0))},derive:function(t,i){const n=[];for(let e=t,r=e.length,s=r-1;r>1;r--,s--){const t=[];for(let n,r=0;r<s;r++)n={x:s*(e[r+1].x-e[r].x),y:s*(e[r+1].y-e[r].y)},i&&(n.z=s*(e[r+1].z-e[r].z)),t.push(n);n.push(t),e=t}return n},between:function(t,i,n){return i<=t&&t<=n||__utils.approximately(t,i)||__utils.approximately(t,n)},approximately:function(t,i,n){return abs(t-i)<=(n||1e-6)},length:function(t){const i=__utils.Tvalues.length;let n=0;for(let e,r=0;r<i;r++)e=.5*__utils.Tvalues[r]+.5,n+=__utils.Cvalues[r]*__utils.arcfn(e,t);return.5*n},map:function(t,i,n,e,r){return e+(r-e)*((t-i)/(n-i))},lerp:function(t,i,n){const e={x:i.x+t*(n.x-i.x),y:i.y+t*(n.y-i.y)};return void 0!==i.z&&void 0!==n.z&&(e.z=i.z+t*(n.z-i.z)),e},pointToString:function(t){let i=t.x+"/"+t.y;return void 0!==t.z&&(i+="/"+t.z),i},pointsToString:function(t){return"["+t.map(__utils.pointToString).join(", ")+"]"},copy:function(t){return JSON.parse(JSON.stringify(t))},angle:function(t,i,n){const e=i.x-t.x,r=i.y-t.y,s=n.x-t.x,o=n.y-t.y;return atan2(e*o-r*s,e*s+r*o)},round:function(t,i){const n=""+t,e=n.indexOf(".");return parseFloat(n.substring(0,e+1+i))},dist:function(t,i){const n=t.x-i.x,e=t.y-i.y;return sqrt(n*n+e*e)},closest:function(t,i){let n,e,r=pow(2,63);return t.forEach((function(t,s){e=__utils.dist(i,t),e<r&&(r=e,n=s)})),{mdist:r,mpos:n}},abcratio:function(t,i){if(2!==i&&3!==i)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=pow(t,i)+pow(1-t,i);return abs((n-1)/n)},projectionratio:function(t,i){if(2!==i&&3!==i)return!1;if(void 0===t)t=.5;else if(0===t||1===t)return t;const n=pow(1-t,i);return n/(pow(t,i)+n)},lli8:function(t,i,n,e,r,s,o,_){const u=(t-n)*(s-_)-(i-e)*(r-o);return 0!=u&&{x:((t*e-i*n)*(r-o)-(t-n)*(r*_-s*o))/u,y:((t*e-i*n)*(s-_)-(i-e)*(r*_-s*o))/u}},lli4:function(t,i,n,e){const r=t.x,s=t.y,o=i.x,_=i.y,u=n.x,c=n.y,l=e.x,a=e.y;return __utils.lli8(r,s,o,_,u,c,l,a)},lli:function(t,i){return __utils.lli4(t,t.c,i,i.c)},makeline:function(t,i){return new __Bezier(t.x,t.y,(t.x+i.x)/2,(t.y+i.y)/2,i.x,i.y)},findbbox:function(t){let i=__nMax,n=__nMax,e=__nMin,r=__nMin;return t.forEach((function(t){const s=t.bbox();i>s.x.min&&(i=s.x.min),n>s.y.min&&(n=s.y.min),e<s.x.max&&(e=s.x.max),r<s.y.max&&(r=s.y.max)})),{x:{min:i,mid:(i+e)/2,max:e,size:e-i},y:{min:n,mid:(n+r)/2,max:r,size:r-n}}},shapeintersections:function(t,i,n,e,r){if(!__utils.bboxoverlap(i,e))return[];const s=[],o=[t.startcap,t.forward,t.back,t.endcap],_=[n.startcap,n.forward,n.back,n.endcap];return o.forEach((function(i){i.virtual||_.forEach((function(e){if(e.virtual)return;const o=i.intersects(e,r);o.length>0&&(o.c1=i,o.c2=e,o.s1=t,o.s2=n,s.push(o))}))})),s},makeshape:function(t,i,n){const e=i.points.length,r=t.points.length,s=__utils.makeline(i.points[e-1],t.points[0]),o=__utils.makeline(t.points[r-1],i.points[0]),_={startcap:s,forward:t,back:i,endcap:o,bbox:__utils.findbbox([s,t,i,o]),intersections:function(t){return __utils.shapeintersections(_,_.bbox,t,t.bbox,n)}};return _},getminmax:function(t,i,n){if(!n)return{min:0,max:0};let e,r,s=__nMax,o=__nMin;-1===n.indexOf(0)&&(n=[0].concat(n)),-1===n.indexOf(1)&&n.push(1);for(let _=0,u=n.length;_<u;_++)e=n[_],r=t.get(e),r[i]<s&&(s=r[i]),r[i]>o&&(o=r[i]);return{min:s,mid:(s+o)/2,max:o,size:o-s}},align:function(t,i){const n=i.p1.x,e=i.p1.y,r=-atan2(i.p2.y-e,i.p2.x-n);return t.map((function(t){return{x:(t.x-n)*cos(r)-(t.y-e)*sin(r),y:(t.x-n)*sin(r)+(t.y-e)*cos(r)}}))},roots:function(t,i){i=i||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=t.length-1,e=__utils.align(t,i),r=function(t){return 0<=t&&t<=1};if(2===n){const t=e[0].y,i=e[1].y,n=e[2].y,s=t-2*i+n;if(0!==s){const e=-sqrt(i*i-t*n),o=-t+i;return[-(e+o)/s,-(-e+o)/s].filter(r)}return i!==n&&0===s?[(2*i-n)/(2*i-2*n)].filter(r):[]}const s=e[0].y,o=e[1].y,_=e[2].y;let u=3*o-s-3*_+e[3].y,c=3*s-6*o+3*_,l=-3*s+3*o,a=s;if(__utils.approximately(u,0)){if(__utils.approximately(c,0))return __utils.approximately(l,0)?[]:[-a/l].filter(r);const t=sqrt(l*l-4*c*a),i=2*c;return[(t-l)/i,(-l-t)/i].filter(r)}c/=u,l/=u,a/=u;const h=(3*l-c*c)/3,x=h/3,y=(2*c*c*c-9*c*l+27*a)/27,p=y/2,f=p*p+x*x*x;let d,m,z,g,v;if(f<0){const t=-h/3,i=sqrt(t*t*t),n=-y/(2*i),e=acos(n<-1?-1:n>1?1:n),s=2*__crt(i);return z=s*cos(e/3)-c/3,g=s*cos((e+__tau)/3)-c/3,v=s*cos((e+2*__tau)/3)-c/3,[z,g,v].filter(r)}if(0===f)return d=p<0?__crt(-p):-__crt(p),z=2*d-c/3,g=-d-c/3,[z,g].filter(r);{const t=sqrt(f);return d=__crt(-p+t),m=__crt(p+t),[d-m-c/3].filter(r)}},droots:function(t){if(3===t.length){const i=t[0],n=t[1],e=t[2],r=i-2*n+e;if(0!==r){const t=-sqrt(n*n-i*e),s=-i+n;return[-(t+s)/r,-(-t+s)/r]}return n!==e&&0===r?[(2*n-e)/(2*(n-e))]:[]}if(2===t.length){const i=t[0],n=t[1];return i!==n?[i/(i-n)]:[]}return[]},curvature:function(t,i,n,e,r){let s,o,_,u,c=0,l=0;const a=__utils.compute(t,i),h=__utils.compute(t,n),x=a.x*a.x+a.y*a.y;if(e?(s=sqrt(pow(a.y*h.z-h.y*a.z,2)+pow(a.z*h.x-h.z*a.x,2)+pow(a.x*h.y-h.x*a.y,2)),o=pow(x+a.z*a.z,1.5)):(s=a.x*h.y-a.y*h.x,o=pow(x,1.5)),0===s||0===o)return{k:0,r:0};if(c=s/o,l=o/s,!r){const r=__utils.curvature(t-.001,i,n,e,!0).k,s=__utils.curvature(t+.001,i,n,e,!0).k;u=(s-c+(c-r))/2,_=(abs(s-c)+abs(c-r))/2}return{k:c,r:l,dk:u,adk:_}},inflections:function(t){if(t.length<4)return[];const i=__utils.align(t,{p1:t[0],p2:t.slice(-1)[0]}),n=i[2].x*i[1].y,e=i[3].x*i[1].y,r=i[1].x*i[2].y,s=18*(-3*n+2*e+3*r-i[3].x*i[2].y),o=18*(3*n-e-3*r),_=18*(r-n);if(__utils.approximately(s,0)){if(!__utils.approximately(o,0)){let t=-_/o;if(0<=t&&t<=1)return[t]}return[]}const u=2*s;if(__utils.approximately(u,0))return[];const c=o*o-4*s*_;if(c<0)return[];const l=Math.sqrt(c);return[(l-o)/u,-(o+l)/u].filter((function(t){return 0<=t&&t<=1}))},bboxoverlap:function(t,i){const n=["x","y"],e=n.length;for(let r,s,o,_,u=0;u<e;u++)if(r=n[u],s=t[r].mid,o=i[r].mid,_=(t[r].size+i[r].size)/2,abs(s-o)>=_)return!1;return!0},expandbox:function(t,i){i.x.min<t.x.min&&(t.x.min=i.x.min),i.y.min<t.y.min&&(t.y.min=i.y.min),i.z&&i.z.min<t.z.min&&(t.z.min=i.z.min),i.x.max>t.x.max&&(t.x.max=i.x.max),i.y.max>t.y.max&&(t.y.max=i.y.max),i.z&&i.z.max>t.z.max&&(t.z.max=i.z.max),t.x.mid=(t.x.min+t.x.max)/2,t.y.mid=(t.y.min+t.y.max)/2,t.z&&(t.z.mid=(t.z.min+t.z.max)/2),t.x.size=t.x.max-t.x.min,t.y.size=t.y.max-t.y.min,t.z&&(t.z.size=t.z.max-t.z.min)},pairiteration:function(t,i,n){const e=t.bbox(),r=i.bbox(),s=1e5,o=n||.5;if(e.x.size+e.y.size<o&&r.x.size+r.y.size<o)return[(s*(t._t1+t._t2)/2|0)/s+"/"+(s*(i._t1+i._t2)/2|0)/s];let _=t.split(.5),u=i.split(.5),c=[{left:_.left,right:u.left},{left:_.left,right:u.right},{left:_.right,right:u.right},{left:_.right,right:u.left}];c=c.filter((function(t){return __utils.bboxoverlap(t.left.bbox(),t.right.bbox())}));let l=[];return 0===c.length||(c.forEach((function(t){l=l.concat(__utils.pairiteration(t.left,t.right,o))})),l=l.filter((function(t,i){return l.indexOf(t)===i}))),l},getccenter:function(t,i,n){const e=i.x-t.x,r=i.y-t.y,s=n.x-i.x,o=n.y-i.y,_=e*cos(__quart)-r*sin(__quart),u=e*sin(__quart)+r*cos(__quart),c=s*cos(__quart)-o*sin(__quart),l=s*sin(__quart)+o*cos(__quart),a=(t.x+i.x)/2,h=(t.y+i.y)/2,x=(i.x+n.x)/2,y=(i.y+n.y)/2,p=a+_,f=h+u,d=x+c,m=y+l,z=__utils.lli8(a,h,p,f,x,y,d,m),g=__utils.dist(z,t);let v,b=atan2(t.y-z.y,t.x-z.x),w=atan2(i.y-z.y,i.x-z.x),B=atan2(n.y-z.y,n.x-z.x);return b<B?((b>w||w>B)&&(b+=__tau),b>B&&(v=B,B=b,b=v)):B<w&&w<b?(v=B,B=b,b=v):B+=__tau,z.s=b,z.e=B,z.r=g,z},numberSort:function(t,i){return t-i}};class __PolyBezier{constructor(t){this.curves=[],this._3d=!1,t&&(this.curves=t,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map((function(t){return __utils.pointsToString(t.points)})).join(", ")+"]"}addCurve(t){this.curves.push(t),this._3d=this._3d||t._3d}length(){return this.curves.map((function(t){return t.length()})).reduce((function(t,i){return t+i}))}curve(t){return this.curves[t]}bbox(){const t=this.curves;for(var i=t[0].bbox(),n=1;n<t.length;n++)__utils.expandbox(i,t[n].bbox());return i}offset(t){const i=[];return this.curves.forEach((function(n){i.push(...n.offset(t))})),new __PolyBezier(i)}}class __Bezier{constructor(t){let i=t&&t.forEach?t:Array.from(arguments).slice(),n=!1;if("object"==typeof i[0]){n=i.length;const t=[];i.forEach((function(i){["x","y","z"].forEach((function(n){void 0!==i[n]&&t.push(i[n])}))})),i=t}let e=!1;const r=i.length;if(n){if(n>4){if(1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");e=!0}}else if(6!==r&&8!==r&&9!==r&&12!==r&&1!==arguments.length)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const s=this._3d=!e&&(9===r||12===r)||t&&t[0]&&void 0!==t[0].z,o=this.points=[];for(let t=0,n=s?3:2;t<r;t+=n){var _={x:i[t],y:i[t+1]};s&&(_.z=i[t+2]),o.push(_)}const u=this.order=o.length-1,c=this.dims=["x","y"];s&&c.push("z"),this.dimlen=c.length;const l=__utils.align(o,{p1:o[0],p2:o[u]}),a=__utils.dist(o[0],o[u]);this._linear=l.reduce(((t,i)=>t+abs(i.y)),0)<a/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(t,i,n,e){if(void 0===e&&(e=.5),0===e)return new __Bezier(i,i,n);if(1===e)return new __Bezier(t,i,i);const r=__Bezier.getABC(2,t,i,n,e);return new __Bezier(t,r.A,n)}static cubicFromPoints(t,i,n,e,r){void 0===e&&(e=.5);const s=__Bezier.getABC(3,t,i,n,e);void 0===r&&(r=__utils.dist(i,s.C));const o=r*(1-e)/e,_=__utils.dist(t,n),u=(n.x-t.x)/_,c=(n.y-t.y)/_,l=r*u,a=r*c,h=o*u,x=o*c,y=i.x-l,p=i.y-a,f=i.x+h,d=i.y+x,m=s.A,z=m.x+(y-m.x)/(1-e),g=m.y+(p-m.y)/(1-e),v=m.x+(f-m.x)/e,b=m.y+(d-m.y)/e,w={x:t.x+(z-t.x)/e,y:t.y+(g-t.y)/e},B={x:n.x+(v-n.x)/(1-e),y:n.y+(b-n.y)/(1-e)};return new __Bezier(t,w,B,n)}static getUtils(){return __utils}getUtils(){return __Bezier.getUtils()}static get PolyBezier(){return __PolyBezier}valueOf(){return this.toString()}toString(){return __utils.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const t=this.points,i=["M",t[0].x,t[0].y,2===this.order?"Q":"C"];for(let n=1,e=t.length;n<e;n++)i.push(t[n].x),i.push(t[n].y);return i.join(" ")}setRatios(t){if(t.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=t,this._lut=[]}verify(){const t=this.coordDigest();t!==this._print&&(this._print=t,this.update())}coordDigest(){return this.points.map((function(t,i){return""+i+t.x+t.y+(t.z?t.z:0)})).join("")}update(){this._lut=[],this.dpoints=__utils.derive(this.points,this._3d),this.computedirection()}computedirection(){const t=this.points,i=__utils.angle(t[0],t[this.order],t[1]);this.clockwise=i>0}length(){return __utils.length(this.derivative.bind(this))}static getABC(t=2,i,n,e,r=.5){const s=__utils.projectionratio(r,t),o=1-s,_={x:s*i.x+o*e.x,y:s*i.y+o*e.y},u=__utils.abcratio(r,t);return{A:{x:n.x+(n.x-_.x)/u,y:n.y+(n.y-_.y)/u},B:n,C:_,S:i,E:e}}getABC(t,i){i=i||this.get(t);let n=this.points[0],e=this.points[this.order];return __Bezier.getABC(this.order,n,i,e,t)}getLUT(t){if(this.verify(),t=t||100,this._lut.length===t)return this._lut;this._lut=[],t++,this._lut=[];for(let i,n,e=0;e<t;e++)n=e/(t-1),i=this.compute(n),i.t=n,this._lut.push(i);return this._lut}on(i,n){n=n||5;const e=this.getLUT(),r=[];for(let t,s=0,o=0;s<e.length;s++)t=e[s],__utils.dist(t,i)<n&&(r.push(t),o+=s/e.length);return!!r.length&&(t/=r.length)}project(t){const i=this.getLUT(),n=i.length-1,e=__utils.closest(i,t),r=e.mpos,s=(r-1)/n,o=(r+1)/n,_=.1/n;let u,c=e.mdist,l=s,a=l;c+=1;for(let i;l<o+_;l+=_)u=this.compute(l),i=__utils.dist(t,u),i<c&&(c=i,a=l);return a=a<0?0:a>1?1:a,u=this.compute(a),u.t=a,u.d=c,u}get(t){return this.compute(t)}point(t){return this.points[t]}compute(t){return this.ratios?__utils.computeWithRatios(t,this.points,this.ratios,this._3d):__utils.compute(t,this.points,this._3d,this.ratios)}raise(){const t=this.points,i=[t[0]],n=t.length;for(let e,r,s=1;s<n;s++)e=t[s],r=t[s-1],i[s]={x:(n-s)/n*e.x+s/n*r.x,y:(n-s)/n*e.y+s/n*r.y};return i[n]=t[n-1],new __Bezier(i)}derivative(t){return __utils.compute(t,this.dpoints[0],this._3d)}dderivative(t){return __utils.compute(t,this.dpoints[1],this._3d)}align(){let t=this.points;return new __Bezier(__utils.align(t,{p1:t[0],p2:t[t.length-1]}))}curvature(t){return __utils.curvature(t,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return __utils.inflections(this.points)}normal(t){return this._3d?this.__normal3(t):this.__normal2(t)}__normal2(t){const i=this.derivative(t),n=sqrt(i.x*i.x+i.y*i.y);return{t:t,x:-i.y/n,y:i.x/n}}__normal3(t){const i=this.derivative(t),n=this.derivative(t+.01),e=sqrt(i.x*i.x+i.y*i.y+i.z*i.z),r=sqrt(n.x*n.x+n.y*n.y+n.z*n.z);i.x/=e,i.y/=e,i.z/=e,n.x/=r,n.y/=r,n.z/=r;const s={x:n.y*i.z-n.z*i.y,y:n.z*i.x-n.x*i.z,z:n.x*i.y-n.y*i.x},o=sqrt(s.x*s.x+s.y*s.y+s.z*s.z);s.x/=o,s.y/=o,s.z/=o;const _=[s.x*s.x,s.x*s.y-s.z,s.x*s.z+s.y,s.x*s.y+s.z,s.y*s.y,s.y*s.z-s.x,s.x*s.z-s.y,s.y*s.z+s.x,s.z*s.z];return{t:t,x:_[0]*i.x+_[1]*i.y+_[2]*i.z,y:_[3]*i.x+_[4]*i.y+_[5]*i.z,z:_[6]*i.x+_[7]*i.y+_[8]*i.z}}hull(t){let i=this.points,n=[],e=[],r=0;for(e[r++]=i[0],e[r++]=i[1],e[r++]=i[2],3===this.order&&(e[r++]=i[3]);i.length>1;){n=[];for(let s,o=0,_=i.length-1;o<_;o++)s=__utils.lerp(t,i[o],i[o+1]),e[r++]=s,n.push(s);i=n}return e}split(t,i){if(0===t&&i)return this.split(i).left;if(1===i)return this.split(t).right;const n=this.hull(t),e={left:2===this.order?new __Bezier([n[0],n[3],n[5]]):new __Bezier([n[0],n[4],n[7],n[9]]),right:2===this.order?new __Bezier([n[5],n[4],n[2]]):new __Bezier([n[9],n[8],n[6],n[3]]),span:n};return e.left._t1=__utils.map(0,0,1,this._t1,this._t2),e.left._t2=__utils.map(t,0,1,this._t1,this._t2),e.right._t1=__utils.map(t,0,1,this._t1,this._t2),e.right._t2=__utils.map(1,0,1,this._t1,this._t2),i?(i=__utils.map(i,t,1,0,1),e.right.split(i).left):e}extrema(){const t={};let i=[];return this.dims.forEach(function(n){let e=function(t){return t[n]},r=this.dpoints[0].map(e);t[n]=__utils.droots(r),3===this.order&&(r=this.dpoints[1].map(e),t[n]=t[n].concat(__utils.droots(r))),t[n]=t[n].filter((function(t){return t>=0&&t<=1})),i=i.concat(t[n].sort(__utils.numberSort))}.bind(this)),t.values=i.sort(__utils.numberSort).filter((function(t,n){return i.indexOf(t)===n})),t}bbox(){const t=this.extrema(),i={};return this.dims.forEach(function(n){i[n]=__utils.getminmax(this,n,t[n])}.bind(this)),i}overlaps(t){const i=this.bbox(),n=t.bbox();return __utils.bboxoverlap(i,n)}offset(t,i){if(void 0!==i){const n=this.get(t),e=this.normal(t),r={c:n,n:e,x:n.x+e.x*i,y:n.y+e.y*i};return this._3d&&(r.z=n.z+e.z*i),r}if(this._linear){const i=this.normal(0),n=this.points.map((function(n){const e={x:n.x+t*i.x,y:n.y+t*i.y};return n.z&&i.z&&(e.z=n.z+t*i.z),e}));return[new __Bezier(n)]}return this.reduce().map((function(i){return i._linear?i.offset(t)[0]:i.scale(t)}))}simple(){if(3===this.order){const t=__utils.angle(this.points[0],this.points[3],this.points[1]),i=__utils.angle(this.points[0],this.points[3],this.points[2]);if(t>0&&i<0||t<0&&i>0)return!1}const t=this.normal(0),i=this.normal(1);let n=t.x*i.x+t.y*i.y;return this._3d&&(n+=t.z*i.z),abs(acos(n))<__pi/3}reduce(){let t,i,n=0,e=0,r=.01,s=[],o=[],_=this.extrema().values;for(-1===_.indexOf(0)&&(_=[0].concat(_)),-1===_.indexOf(1)&&_.push(1),n=_[0],t=1;t<_.length;t++)e=_[t],i=this.split(n,e),i._t1=n,i._t2=e,s.push(i),n=e;return s.forEach((function(t){for(n=0,e=0;e<=1;)for(e=n+r;e<=1.01;e+=r)if(i=t.split(n,e),!i.simple()){if(e-=r,abs(n-e)<r)return[];i=t.split(n,e),i._t1=__utils.map(n,0,1,t._t1,t._t2),i._t2=__utils.map(e,0,1,t._t1,t._t2),o.push(i),n=e;break}n<1&&(i=t.split(n,1),i._t1=__utils.map(n,0,1,t._t1,t._t2),i._t2=t._t2,o.push(i))})),o}translate(t,i,n){n="number"==typeof n?n:i;const e=this.order;let r=this.points.map(((t,r)=>(1-r/e)*i+r/e*n));return new __Bezier(this.points.map(((i,n)=>({x:i.x+t.x*r[n],y:i.y+t.y*r[n]}))))}scale(t){const i=this.order;let n=!1;if("function"==typeof t&&(n=t),n&&2===i)return this.raise().scale(n);const e=this.clockwise,r=this.points;if(this._linear)return this.translate(this.normal(0),n?n(0):t,n?n(1):t);const s=n?n(0):t,o=n?n(1):t,_=[this.offset(0,10),this.offset(1,10)],u=[],c=__utils.lli4(_[0],_[0].c,_[1],_[1].c);if(!c)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach((function(t){const n=u[t*i]=__utils.copy(r[t*i]);n.x+=(t?o:s)*_[t].n.x,n.y+=(t?o:s)*_[t].n.y})),n?([0,1].forEach((function(s){if(2!==i||!s){var o=r[s+1],_={x:o.x-c.x,y:o.y-c.y},l=n?n((s+1)/i):t;n&&!e&&(l=-l);var a=sqrt(_.x*_.x+_.y*_.y);_.x/=a,_.y/=a,u[s+1]={x:o.x+l*_.x,y:o.y+l*_.y}}})),new __Bezier(u)):([0,1].forEach((t=>{if(2===i&&t)return;const n=u[t*i],e=this.derivative(t),s={x:n.x+e.x,y:n.y+e.y};u[t+1]=__utils.lli4(n,s,c,r[t+1])})),new __Bezier(u))}outline(t,i,n,e){if(i=void 0===i?t:i,this._linear){const r=this.normal(0),s=this.points[0],o=this.points[this.points.length-1];let _,u,c;void 0===n&&(n=t,e=i),_={x:s.x+r.x*t,y:s.y+r.y*t},c={x:o.x+r.x*n,y:o.y+r.y*n},u={x:(_.x+c.x)/2,y:(_.y+c.y)/2};const l=[_,u,c];_={x:s.x-r.x*i,y:s.y-r.y*i},c={x:o.x-r.x*e,y:o.y-r.y*e},u={x:(_.x+c.x)/2,y:(_.y+c.y)/2};const a=[c,u,_],h=__utils.makeline(a[2],l[0]),x=__utils.makeline(l[2],a[0]),y=[h,new __Bezier(l),x,new __Bezier(a)];return new __PolyBezier(y)}const r=this.reduce(),s=r.length,o=[];let _,u=[],c=0,l=this.length();const a=void 0!==n&&void 0!==e;function h(t,i,n,e,r){return function(s){const o=e/n,_=(e+r)/n,u=i-t;return __utils.map(s,0,1,t+o*u,t+_*u)}}r.forEach((function(r){const s=r.length();a?(o.push(r.scale(h(t,n,l,c,s))),u.push(r.scale(h(-i,-e,l,c,s)))):(o.push(r.scale(t)),u.push(r.scale(-i))),c+=s})),u=u.map((function(t){return _=t.points,_[3]?t.points=[_[3],_[2],_[1],_[0]]:t.points=[_[2],_[1],_[0]],t})).reverse();const x=o[0].points[0],y=o[s-1].points[o[s-1].points.length-1],p=u[s-1].points[u[s-1].points.length-1],f=u[0].points[0],d=__utils.makeline(p,x),m=__utils.makeline(y,f),z=[d].concat(o).concat([m]).concat(u);return new __PolyBezier(z)}outlineshapes(t,i,n){i=i||t;const e=this.outline(t,i).curves,r=[];for(let t=1,i=e.length;t<i/2;t++){const s=__utils.makeshape(e[t],e[i-t],n);s.startcap.virtual=t>1,s.endcap.virtual=t<i/2-1,r.push(s)}return r}intersects(t,i){return t?t.p1&&t.p2?this.lineIntersects(t):(t instanceof __Bezier&&(t=t.reduce()),this.curveintersects(this.reduce(),t,i)):this.selfintersects(i)}lineIntersects(t){const i=min(t.p1.x,t.p2.x),n=min(t.p1.y,t.p2.y),e=max(t.p1.x,t.p2.x),r=max(t.p1.y,t.p2.y);return __utils.roots(this.points,t).filter((t=>{var s=this.get(t);return __utils.between(s.x,i,e)&&__utils.between(s.y,n,r)}))}selfintersects(t){const i=this.reduce(),n=i.length-2,e=[];for(let r,s,o,_=0;_<n;_++)s=i.slice(_,_+1),o=i.slice(_+2),r=this.curveintersects(s,o,t),e.push(...r);return e}curveintersects(t,i,n){const e=[];t.forEach((function(t){i.forEach((function(i){t.overlaps(i)&&e.push({left:t,right:i})}))}));let r=[];return e.forEach((function(t){const i=__utils.pairiteration(t.left,t.right,n);i.length>0&&(r=r.concat(i))})),r}arcs(t){return t=t||.5,this._iterate(t,[])}_error(t,i,n,e){const r=(e-n)/4,s=this.get(n+r),o=this.get(e-r),_=__utils.dist(t,i),u=__utils.dist(t,s),c=__utils.dist(t,o);return abs(u-_)+abs(c-_)}_iterate(t,i){let n,e=0,r=1;do{n=0,r=1;let s,o,_,u,c,l=this.get(e),a=!1,h=!1,x=r,y=1,p=0;do{if(h=a,u=_,x=(e+r)/2,p++,s=this.get(x),o=this.get(r),_=__utils.getccenter(l,s,o),_.interval={start:e,end:r},a=this._error(_,l,e,r)<=t,c=h&&!a,c||(y=r),a){if(r>=1){if(_.interval.end=y=1,u=_,r>1){let t={x:_.x+_.r*cos(_.e),y:_.y+_.r*sin(_.e)};_.e+=__utils.angle({x:_.x,y:_.y},t,this.get(1))}break}r+=(r-e)/2}else r=x}while(!c&&n++<100);if(n>=100)break;u=u||_,i.push(u),e=y}while(r<1);return i}}class __Vector2{constructor(t,i){this.x=t,this.y=i}}const __origin={x:0,y:0},__sub=(t,i)=>({x:t.x-i.x,y:t.y-i.y}),__div=(t,i)=>({x:t.x/i,y:t.y/i}),__mult=(t,i)=>({x:t.x*i,y:t.y*i}),__add=(t,i)=>({x:t.x+i.x,y:t.y+i.y}),__direction=(t,i)=>__sub(i,t),__perpendicular=t=>({x:t.y,y:-1*t.x}),__magnitude=t=>Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2)),__unit=t=>__div(t,__magnitude(t)),__setMagnitude=(t,i)=>__mult(__unit(t),i),__vec_distance=(t,i)=>__magnitude(__direction(t,i)),__randomNumberRange=(t,i)=>Math.random()*(i-t)+t,__randomVectorOnLine=(t,i)=>{const n=__direction(t,i),e=Math.random();return __add(t,__mult(n,e))},__randomNormalLine=(t,i,n)=>{const e=__randomVectorOnLine(t,i);return[e,__setMagnitude(__perpendicular(__direction(t,e)),n)]},__generateBezierAnchors=(t,i,n)=>{const e=1===Math.round(Math.random())?1:-1,r=()=>{const[r,s]=__randomNormalLine(t,i,n),o=__mult(s,e);return __randomVectorOnLine(r,__add(r,o))};return[r(),r()].sort(((t,i)=>t.x-i.x))},__clamp=(t,i,n)=>Math.min(n,Math.max(i,t)),__overshoot=(t,i)=>{const n=2*Math.random()*Math.PI,e=i*Math.sqrt(Math.random()),r={x:e*Math.cos(n),y:e*Math.sin(n)};return __add(t,r)},__bezierCurve=(t,i,n)=>{const e=__direction(t,i),r=__magnitude(e),s=__clamp(r,2,200),o=__generateBezierAnchors(t,i,n||s);return new __Bezier(t,...o,i)},__fitts=(t,i)=>0+2*Math.log2(t/i+1),__getRandomBoxPoint=({x:t,y:i,width:n,height:e},r)=>{let s=0,o=0;return void 0!==r?.paddingPercentage&&r?.paddingPercentage>0&&r?.paddingPercentage<100&&(s=n*r.paddingPercentage/100,o=e*r.paddingPercentage/100),{x:t+s/2+Math.random()*(n-s),y:i+o/2+Math.random()*(e-o)}},__clampPositive=t=>{const i=t=>Math.max(0,t);return t.map((t=>({x:i(t.x),y:i(t.y)})))};function __path(t,i){const n=__bezierCurve(t,i,null),e=.8*n.length(),r=Math.ceil(3*(Math.log2(__fitts(e,20)+1)+75)),s=n.getLUT(r);return __clampPositive(s)}